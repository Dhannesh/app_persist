# Persisting Data on the Local Device
When building mobile applications, there is often the need to store data locally on the mobile device, either across the applicationâ€™s sessions or to store user preferences. Based on the size and complexity of the data, there are several choices to store data locally.
## Local Persistence in Flutter
![img.png](img.png)
Let's say you need to store data locally in Flutter, that is, you need to persist data on your mobile device. What are the options you have? There are a number of different options. We'll discuss just the three most common. The first is you can store data on the file system of your mobile device. This of course involves reading from and writing to files. Or you can store data locally using SharedPreferences. This allows you to store data in the form of key-value pairs typically used for user's preference data. Yet another option is you store data in an embedded database such as SQLite. This allows you to query your data using SQL queries, manipulate your data and everything that you'd expect from a database. When would you choose to use the file system to store data?

The file system is a great option if you have unstructured data, maybe data in the form of long form text and you want to preserve this data across app launches. The file system is also a great option if you want to download and store data that you've accessed from the Internet and you want to be able to access this data offline later on sometime. Another reason to potentially use files to store data is that you want to be able to share the file with other users using some kind of sharing services, maybe e-mail or some kind of messenger service. With Flutter, storing files on your local device is very straightforward. Flutter apps can use libraries to access, read, and write data stored on your device's disk. Your mobile device has a file system, and there are certain locations in that file system that your app can write to.

You'll use the **path_provider** plugin to find correct local path on disk where you want to write your files. And then you'll use the **dart:io** library to read data from and write data to the file. The path_provider package is an extremely useful dart library that provides a platform-agnostic way to access locations on the device's file system. With the path_provider, you use the same set of APIs whether you're running your Flutter app on Android, iOS, or some other mobile device. Now, there are different local paths that are accessible by Flutter. There is a temporary directory on your device that is a cache that is available to the system as a whole. The system can clear this at any point-in-time. This temporary directory is not entirely in your app's control, so you may want to think twice before you store your files there. Instead, you may want to use the **documents directory**.

The documents directory allows the app to store files where only the app can access those files. So your mobile operating system cannot delete files in this documents directory, unless you delete your app. The system clears this data only when the app is deleted. The app controls this data until then. We've discussed persisting data in files on a local device. Next, let's discuss SharedPreferences to persist data locally. First, we'll discuss when you would choose to use SharedPreferences to store data. If you have collections of data where your data is rather lightweight and can be represented using key-value pairs, SharedPreferences is the right choice. As the name implies, this is often used to store user preferences such as font size or theme. This is very useful for small amounts of data, data that is local to the app, data that need not be shared with other people or applications. When you use SharedPreferences to store data, you use the **SharedPreferences plugin**. This plugin wraps the **NSUserDefaults** on iOS and the **SharedPreferences** on Android. The data that you store using SharedPreferences can't be very complex. It supports only primitive types such as int, double, boolean, string, and a list of strings. Data is stored in the form of key-value pairs. Keys are always strings and values can be these other primitive types. Key-value pairs are updated synchronously in memory first and then asynchronously written out to disk. Reading a value using a particular key is always synchronous. 

Now let's move on to discussing the third technique that you can use to persist data using SQLite.  SQLite is a database engine written in the C programming language. SQLite is actually an embedded database. Software developers use the SQLite library, and that database is embedded into the application. If you want to persist large amounts of data on your local device, you need a way to store and query this data efficiently. You need an interface that supports SQL queries, allowing you to access and manipulate data. That's when SQLite is really useful. This also means that the data that you store in SQLite can be more complex. You can have entities with multiple attributes. You also get faster performance from your queries for inserts, deletes, and updates when you use SQLite. When you use SQLite from within Flutter, you'll need to use the **SQFlite** package. This is what gives you the classes and functions that you need to interact with the SQLite database. In addition, you'll need to use the **path package**, which gives you functions to define the location for where you want the database to be stored on disk.

## Reading Text Data Using the Flutter Services Library
In this demo, we'll see a number of different techniques that we can use in Flutter to read and write files from the local device. In this first iteration of our application, I'm going to read a file that is present as a part of the asset bundle of our app. So, we'll see how we can read a file that is bundled in along with images and other assets within our application. I have a Flutter project that's already set up and open within Android Studio. I'm going to create a New Directory, which is going to hold the files that will be included as a part of the assets of this app. These will be within the files subfolder.
So, within this file subfolder, I'm going to right-click and create a New File, and this file will be named about.txt. This is the file that we'll read from within our app. In order for this file to be included as a part of the assets of this mobile application that we are about to build, I need to make an entry in the pubspec.yaml file. Open up pubspec.yaml and somewhere in the middle, Within the flutter section, go in and add a section for assets and point that to the files subfolder. This will ensure that all of the contents of the files subfolder will be included as a part of the asset bundles that make up our mobile app. The AboutPage is a StatefulWidget that's defined right here in this file. This _data member variable contains the contents of the about.txt file when we load in the contents after having read the file. 

The function loadData is an async function within which we actually read in the contents of about.txt and for that I use the rootBundle. This is an async function which is why I need to await the results of this function and the results will be stored in loadedData. I then call setState and set the contents of the about.txt file to my _data variable within setState. Let's take a look at the UI at this AboutPage sets up. Within the build function, This Card has a purple background color And within this Card, I display a Text widget. Now I first check to see whether the _data variable is equal to null. If _data is equal to null, we haven't loaded in the contents of the file yet, and so the Text widget defined displays a large question mark. If _data is not equal to null, that is the file contents have been loaded, we'll display the Text widget. That simply displays the data that we've loaded in from the about.txt file within the Card widget.

## Reading and Parsing Contents of a CSV File
In this demo, we'll see how you can read in and parse the contents of a CSV file. We'll then display the contents of the CSV file in a nice tabular format using the data table widget in Flutter. In order to be able to parse the contents of the CSV file, we need an additional library (CSV). 
You can see that there are four columns of information in this orders.csv file, Date, Status, Category, and Amount. Every entry in this file you can say refers to an order. Now, this file happens to be in the files subfolder which will be included in the asset bundle included with my app. 

The csvData can hold null, it's a nullable type. And it contains a List of List of any type, so a List of List of dynamic. The outer list in this type refers to the rows or the records in our csv file. The inner list refers to the individual fields within the record, and the individual fields can be of any type. They can be string, integers, anything. Now, data is loaded from my orders.csv file and parsed as csv in this process csv method defined in orders_page. I invoke DefaultAssetBundle of the current context and invoke the loadString method within it. And I point to the files/orders.csv file. Now, reading a file is always an asynchronous operation. I await the result of this operation, and I store the result in the result variable. The result variable holds the csv contents in the string format. I instantiate the CsvToListConverter and invoke the convert function and pass in the result as an input. And I indicate that the end of line in this csv format is the \n or the newline character. This will parse the csv originally present as a string to a List of List of dynamic types.

Now let's take a look at the UI that's fairly simple. We'll display the csv data in a tabular format, and I'm going to embed the table within a SingleChildScrollView. You can see that the scrollDirection is horizontal, so we kind of overflow the screen so we'll be able to move around horizontally. If the csvData variable is equal to null, then we simply display an empty Container.
There is no table to view because we haven't loaded in the file yet. If the csvData variable is not null, we'll display the csv contents in a tabular format and the right widget for that is the DataTable. Now, the DataTable has two properties that I have set here, the columns property and the rows property. The columns property basically defines the headers for this tabular format. I access the first row of the csvData and I map the contents of the first row so that every column header is displayed using a DataColumn widget and the label of the DataColumn is simply the name of the column that is displayed using a Text widget. The rows property is basically all of the rows other than the first header row. I use a List.generate function to generate the DataRow widgets that represent the individual rows. The length of this list is equal to the length of the csvData minus 1. 

The app is already running. Let's click on the floatingActionButton with the table icon in order to look at our file contents as a data table. So, you can see this nice tabular format which contains our csv data. You can scroll horizontally in order to view the entire table.

